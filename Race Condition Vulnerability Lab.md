# Race Condition Vulnerability Lab

## Environment Setup

### Turning Off Countermeasures

Symlinks are an example of indirects, and indirects are prone to be vulnerable. The problem with symlink is, its link can be modified to trick some privileged program to make the Time of Check To Time of Use mistake. For example, a SetUID program with root privilege can first check if the real user is allowed to read a /tmp/X file, then if allowed, it will `fopen` this file and write to it. But the problem is, between the time of access check and `fopen`, the `/tmp/X` file may be changed to symlink to another file, e.g, `/etc/passwd`, which the real user has no write permission!

So Ubuntu has this built-in protection call Sticky Directories. According to its documentation, "symlinks in world-writable sticky directories (e.g.
/tmp) cannot be followed if the follower and directory owner do not match the symlink owner." 

Ubuntu 20.04 introduces another security mechanism that prevents the root from writing to the files in /tmp that are owned by others. In this lab, we need to disable these protections. 

// On Ubuntu 20.04, use the following:
```
$ sudo sysctl -w fs.protected_symlinks=0
$ sudo sysctl fs.protected_regular=0
```

### Vulnerable Program

```c
#include <stdio.h>
#include<unistd.h>
int main()
{
	char * fn = "/tmp/XYZ";
	char buffer[60];
	FILE *fp;
	/* get user input */
	scanf("%50s", buffer );
	if(!access(fn, W_OK)){ ➀
		fp = fopen(fn, "a+"); ➁
		fwrite("\n", sizeof(char), 1, fp);
		fwrite(buffer, sizeof(char), strlen(buffer), fp);
		fclose(fp);
	}
	else 
		printf("No permission \n");
}
```

$ gcc vulp.c -o vulp
$ sudo chown root vulp
$ sudo chmod 4755 vulp

The above program is compiled as a root-owned Set-UID program but it has a race condition (time of check permission happends at calling `access`, but time of use happens at `fopen`). 

Why symlink is required for this attack? How about we first have a file with user write permission and then replace it with another file? I think that's still an attack to the race condition but won't be useful for us.

### An Improved Attack

If we try to exploit this program by `unlink and symlink` like this:

```
unlink("/tmp/XYZ");
symlink("/etc/passwd","/tmp/XYZ");
```

We are risking a race condition in our own program! The problem with this is, unlink and symlink are two separate syscalls and they are not atomic! So if this program gets context-switched out, and the vulnerable program gets a chance to run and `fopen` the file, then a new file with the path `/tmp/XYZ` will be created with root as the owner! A bit reference about the unlink syscall:

DESCRIPTION
     The unlink() function removes the link named by path from its directory and decrements the link count of the file which was referenced by the link.  If that
     decrement reduces the link count of the file to zero, and no process has the file open, then all resources associated with the file are reclaimed.  If one or more
     process have the file open when the last link is removed, the link is removed, but the removal of the file is delayed until all references to it have been closed.

In that case, our attack program will not be allowed to do symlink!

How tricky can race conditions be!

We should use the atomic syscall to swap the symlinks and avoid the race condition:

renameat2(0, "/tmp/XYZ", 0, "/tmp/ABC", flags);

### Countermeasures

- Applying the Principle of Least Privilege: We can seteuid to normal user before doing the file operations and take on the effective userid afterwards.

-  Using Ubuntu’s Built-in Scheme:  We can turn on the protected symlink mechanism by running: `$ sudo sysctl -w fs.protected_symlinks=1`. This way when the owner of symlink doesn't match the directory owner and the symlink follwer (in our case, the root user), it will be stopped, i.e, fopen will fail.



